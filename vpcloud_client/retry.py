# coding: utf-8

"""
    Retry strategy and exponential backoff logic for vpcloud_client.

    This module provides intelligent retry logic with exponential backoff,
    status code-based retry decisions, and exception handling.

    Generated by OpenAPI Generator (https://openapi-generator.tech)
    Do not edit the class manually.
"""  # noqa: E501

import time
import random
import logging
from typing import Optional, List, Type, Union, Callable

logger = logging.getLogger("vpcloud_client.retry")


class RetryStrategy:
    """Configures retry behavior for API requests.
    
    Provides intelligent retry logic with exponential backoff, status code
    checking, and exception handling.
    
    :param max_retries: Maximum number of retry attempts (default: 3)
    :param backoff_factor: Multiplier for exponential backoff (default: 2.0)
    :param max_backoff: Maximum backoff delay in seconds (default: 60.0)
    :param retry_on_status: List of HTTP status codes to retry on (default: [429, 500, 502, 503, 504])
    :param retry_on_exceptions: List of exception types to retry on (default: [TimeoutError, ConnectionError])
    :param respect_retry_after_header: Whether to respect Retry-After header for 429 responses (default: True)
    :param jitter: Whether to add random jitter to backoff delays (default: True)
    """
    
    def __init__(
        self,
        max_retries: int = 3,
        backoff_factor: float = 2.0,
        max_backoff: float = 60.0,
        retry_on_status: Optional[List[int]] = None,
        retry_on_exceptions: Optional[List[Type[Exception]]] = None,
        respect_retry_after_header: bool = True,
        jitter: bool = True,
    ):
        """Initialize retry strategy."""
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
        self.max_backoff = max_backoff
        self.retry_on_status = retry_on_status or [429, 500, 502, 503, 504]
        self.retry_on_exceptions = retry_on_exceptions or [TimeoutError, ConnectionError]
        self.respect_retry_after_header = respect_retry_after_header
        self.jitter = jitter
    
    def should_retry(self, status_code: int) -> bool:
        """Check if a status code should trigger a retry.
        
        :param status_code: HTTP status code
        :return: True if status code is in retry_on_status list
        """
        return status_code in self.retry_on_status
    
    def should_retry_exception(self, exception: Exception) -> bool:
        """Check if an exception should trigger a retry.
        
        :param exception: Exception that occurred
        :return: True if exception type is in retry_on_exceptions list
        """
        return any(isinstance(exception, exc_type) for exc_type in self.retry_on_exceptions)
    
    def get_backoff_delay(self, attempt: int, retry_after: Optional[float] = None) -> float:
        """Calculate backoff delay for a retry attempt.
        
        Uses exponential backoff with optional jitter and respects Retry-After header.
        
        :param attempt: Current attempt number (1-indexed)
        :param retry_after: Value from Retry-After header (in seconds), if present
        :return: Delay in seconds before next retry
        """
        # If Retry-After header is present and we respect it, use that value
        if retry_after is not None and self.respect_retry_after_header:
            delay = float(retry_after)
        else:
            # Exponential backoff: base_delay * (backoff_factor ^ (attempt - 1))
            delay = self.backoff_factor ** (attempt - 1)
        
        # Cap at max_backoff
        delay = min(delay, self.max_backoff)
        
        # Add jitter (random value between 0 and 25% of delay)
        if self.jitter:
            jitter_amount = delay * 0.25 * random.random()
            delay = delay + jitter_amount
        
        return delay
    
    def parse_retry_after_header(self, retry_after_value: Optional[str]) -> Optional[float]:
        """Parse Retry-After header value.
        
        Supports both integer seconds and HTTP-date format.
        
        :param retry_after_value: Value from Retry-After header
        :return: Delay in seconds, or None if invalid
        """
        if retry_after_value is None:
            return None
        
        try:
            # Try parsing as integer (seconds)
            return float(retry_after_value)
        except (ValueError, TypeError):
            try:
                # Try parsing as HTTP-date (RFC 7231)
                from email.utils import parsedate_to_datetime
                retry_date = parsedate_to_datetime(retry_after_value)
                now = time.time()
                retry_timestamp = retry_date.timestamp()
                delay = retry_timestamp - now
                return max(0.0, delay) if delay > 0 else None
            except (ValueError, TypeError, ImportError):
                logger.warning(f"Could not parse Retry-After header: {retry_after_value}")
                return None
