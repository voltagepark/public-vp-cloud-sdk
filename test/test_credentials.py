# coding: utf-8

"""
    Credentials and Auth0 unit tests for vpcloud_client.

    Generated by OpenAPI Generator (https://openapi-generator.tech)
    Do not edit the class manually.
"""  # noqa: E501

import pytest
import os
import time
from unittest.mock import Mock, patch, MagicMock, mock_open
from pathlib import Path
from vpcloud_client.credentials import (
    CredentialProvider,
    Auth0TokenManager,
    AuthenticationError
)
from vpcloud_client import Configuration


class TestCredentialProvider:
    """CredentialProvider unit tests"""

    def test_explicit_access_token_takes_priority(self):
        """Test explicit access token has highest priority."""
        provider = CredentialProvider(access_token="explicit-token")
        assert provider.get_access_token() == "explicit-token"

    @patch.dict(os.environ, {"VPCLOUD_ACCESS_TOKEN": "env-token"})
    def test_environment_variable_access_token(self):
        """Test access token from environment variable."""
        provider = CredentialProvider()
        assert provider.get_access_token() == "env-token"

    @patch.dict(os.environ, {}, clear=True)
    @patch("vpcloud_client.credentials.Path.exists")
    @patch("builtins.open", new_callable=mock_open, read_data="[default]\naccess_token=file-token")
    def test_credentials_file_access_token(self, mock_file, mock_exists):
        """Test access token from credentials file."""
        mock_exists.return_value = True
        provider = CredentialProvider()
        assert provider.get_access_token() == "file-token"

    @patch.dict(os.environ, {"VPCLOUD_CLIENT_ID": "test-client-id", "VPCLOUD_CLIENT_SECRET": "test-secret"})
    def test_client_credentials_from_env(self):
        """Test client credentials from environment."""
        provider = CredentialProvider()
        client_id, client_secret = provider.get_client_credentials()
        assert client_id == "test-client-id"
        assert client_secret == "test-secret"

    def test_credential_resolution_priority(self):
        """Test credential resolution priority order."""
        # Explicit > Env > File
        with patch.dict(os.environ, {"VPCLOUD_ACCESS_TOKEN": "env-token"}):
            provider = CredentialProvider(access_token="explicit-token")
            assert provider.get_access_token() == "explicit-token"

    def test_profile_selection(self):
        """Test credential provider uses correct profile."""
        provider = CredentialProvider(profile="production")
        assert provider._profile == "production"

    @patch.dict(os.environ, {}, clear=True)
    @patch("vpcloud_client.credentials.Path.exists")
    def test_no_credentials_returns_none(self, mock_exists):
        """Test that None is returned when no credentials found."""
        mock_exists.return_value = False  # Credentials file doesn't exist
        provider = CredentialProvider()
        assert provider.get_access_token() is None
        client_id, client_secret = provider.get_client_credentials()
        assert client_id is None
        assert client_secret is None


class TestAuth0TokenManager:
    """Auth0TokenManager unit tests"""

    @patch("vpcloud_client.credentials.httpx")
    def test_token_exchange_success(self, mock_httpx):
        """Test successful Auth0 token exchange."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "test-token",
            "expires_in": 86400
        }
        mock_response.raise_for_status = Mock()
        mock_httpx.post.return_value = mock_response
        
        manager = Auth0TokenManager("client-id", "client-secret")
        token = manager.get_token()
        
        assert token == "test-token"
        assert manager._cached_token == "test-token"
        mock_httpx.post.assert_called_once()

    @patch("vpcloud_client.credentials.httpx")
    @patch("vpcloud_client.credentials.time.time")
    def test_token_caching(self, mock_time, mock_httpx):
        """Test token is cached and reused."""
        mock_time.return_value = 1000.0
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "cached-token",
            "expires_in": 86400
        }
        mock_response.raise_for_status = Mock()
        mock_httpx.post.return_value = mock_response
        
        manager = Auth0TokenManager("client-id", "client-secret")
        token1 = manager.get_token()
        token2 = manager.get_token()
        
        assert token1 == token2 == "cached-token"
        assert mock_httpx.post.call_count == 1  # Only called once

    @patch("vpcloud_client.credentials.httpx")
    @patch("vpcloud_client.credentials.time.time")
    def test_token_refresh_before_expiry(self, mock_time, mock_httpx):
        """Test token is refreshed 60 seconds before expiry."""
        mock_time.return_value = 1000.0
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "new-token",
            "expires_in": 100
        }
        mock_response.raise_for_status = Mock()
        mock_httpx.post.return_value = mock_response
        
        manager = Auth0TokenManager("client-id", "client-secret")
        manager._cached_token = "old-token"
        manager._token_expires_at = 1050.0  # Expires in 50 seconds
        
        token = manager.get_token()
        
        assert token == "new-token"
        assert mock_httpx.post.call_count == 1

    @patch("vpcloud_client.credentials.httpx")
    def test_token_exchange_failure(self, mock_httpx):
        """Test AuthenticationError raised on token exchange failure."""
        # Import the real httpx module to get the actual exception class
        import httpx as real_httpx
        
        # Create a proper HTTPStatusError mock
        mock_response = MagicMock()
        mock_response.status_code = 401
        mock_response.text = "Unauthorized"
        
        # Create HTTPStatusError instance using the real exception class
        error = real_httpx.HTTPStatusError(
            "Bad Request",
            request=MagicMock(),
            response=mock_response
        )
        mock_httpx.post.side_effect = error
        # Make sure HTTPStatusError is accessible through the mock
        mock_httpx.HTTPStatusError = real_httpx.HTTPStatusError
        
        manager = Auth0TokenManager("client-id", "client-secret")
        
        with pytest.raises(AuthenticationError):
            manager.get_token()

    @patch("vpcloud_client.credentials.httpx", None)
    def test_httpx_required(self):
        """Test AuthenticationError when httpx is not installed."""
        manager = Auth0TokenManager("client-id", "client-secret")
        
        with pytest.raises(AuthenticationError, match="httpx is required"):
            manager.get_token()

    @patch("vpcloud_client.credentials.httpx")
    @patch("vpcloud_client.credentials.time.time")
    def test_force_refresh(self, mock_time, mock_httpx):
        """Test force_refresh parameter forces new token."""
        mock_time.return_value = 1000.0
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "new-token",
            "expires_in": 86400
        }
        mock_response.raise_for_status = Mock()
        mock_httpx.post.return_value = mock_response
        
        manager = Auth0TokenManager("client-id", "client-secret")
        manager._cached_token = "old-token"
        manager._token_expires_at = time.time() + 3600  # Valid for 1 hour
        
        token = manager.get_token(force_refresh=True)
        
        assert token == "new-token"
        assert mock_httpx.post.call_count == 1

    @patch("vpcloud_client.credentials.httpx")
    def test_missing_access_token_in_response(self, mock_httpx):
        """Test AuthenticationError when access_token missing from response."""
        # Import the real httpx module to get the actual exception classes
        import httpx as real_httpx
        
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "expires_in": 86400
            # Missing access_token
        }
        mock_response.raise_for_status = Mock()
        mock_httpx.post.return_value = mock_response
        
        # CRITICAL: Set the real exception classes on the mock BEFORE any code runs
        # Python evaluates all except clauses when setting up try/except blocks,
        # so httpx.HTTPStatusError must be a real exception class, not a MagicMock
        mock_httpx.HTTPStatusError = real_httpx.HTTPStatusError
        mock_httpx.RequestError = real_httpx.RequestError
        
        # Also update the reference in the credentials module since it already imported httpx
        from vpcloud_client import credentials
        # Replace the httpx reference but preserve exception classes
        credentials.httpx.HTTPStatusError = real_httpx.HTTPStatusError
        credentials.httpx.RequestError = real_httpx.RequestError
        
        manager = Auth0TokenManager("client-id", "client-secret")
        
        # The exception is raised when access_token is missing
        with pytest.raises(AuthenticationError, match="missing access_token"):
            manager.get_token()


class TestConfigurationCredentials:
    """Configuration credential resolution integration tests"""

    @patch.dict(os.environ, {"VPCLOUD_ACCESS_TOKEN": "env-token"})
    def test_configuration_resolves_env_token(self):
        """Test Configuration resolves token from environment."""
        config = Configuration()
        token = config._resolve_access_token()
        assert token == "env-token"

    def test_configuration_explicit_token(self):
        """Test Configuration uses explicit token."""
        config = Configuration(access_token="explicit-token")
        token = config._resolve_access_token()
        assert token == "explicit-token"

    @patch.dict(os.environ, {"VPCLOUD_CLIENT_ID": "client-id", "VPCLOUD_CLIENT_SECRET": "client-secret"})
    @patch("vpcloud_client.credentials.httpx")
    def test_configuration_auth0_exchange(self, mock_httpx):
        """Test Configuration exchanges Auth0 credentials for token."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "auth0-token",
            "expires_in": 86400
        }
        mock_response.raise_for_status = Mock()
        mock_httpx.post.return_value = mock_response
        
        config = Configuration(client_id="client-id", client_secret="client-secret")
        token = config._resolve_access_token()
        
        assert token == "auth0-token"

    def test_auth_settings_includes_bearer_token(self):
        """Test auth_settings() includes Bearer token in header."""
        config = Configuration(access_token="test-token")
        auth_settings = config.auth_settings()
        
        assert "bearerAuth" in auth_settings
        assert auth_settings["bearerAuth"]["value"] == "Bearer test-token"

    @patch.dict(os.environ, {}, clear=True)
    @patch("vpcloud_client.credentials.Path.exists")
    def test_configuration_no_credentials(self, mock_exists):
        """Test Configuration returns None when no credentials available."""
        mock_exists.return_value = False  # Credentials file doesn't exist
        config = Configuration()
        token = config._resolve_access_token()
        assert token is None

